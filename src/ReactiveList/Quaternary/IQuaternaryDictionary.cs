// Copyright (c) Chris Pulman. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
#if NET8_0_OR_GREATER

namespace CP.Reactive;

/// <summary>
/// Represents a dictionary that supports standard key-value storage as well as additional value-based indexing and
/// bulk operations.
/// </summary>
/// <remarks>In addition to the standard IDictionary functionality, IQuaternaryDictionary provides methods
/// for adding or updating entries, adding multiple entries at once, and creating named indexes on value properties
/// for efficient lookups. This interface is intended for scenarios where advanced indexing and bulk operations are
/// required beyond those provided by typical dictionary implementations.</remarks>
/// <typeparam name="TKey">The type of keys in the dictionary. Must be non-nullable.</typeparam>
/// <typeparam name="TValue">The type of values stored in the dictionary.</typeparam>
public interface IQuaternaryDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IQuaternarySource<KeyValuePair<TKey, TValue>>
    where TKey : notnull
{
    /// <summary>
    /// Adds a new element with the specified key and value, or updates the value if the key already exists.
    /// </summary>
    /// <param name="key">The key of the element to add or update. Cannot be null.</param>
    /// <param name="value">The value to set for the specified key.</param>
    void AddOrUpdate(TKey key, TValue value);

    /// <summary>
    /// Adds the elements of the specified collection to the current collection.
    /// </summary>
    /// <param name="pairs">The collection of key/value pairs to add. Each pair is added to the collection. Cannot be null.</param>
    void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);

    /// <summary>
    /// Adds a value index with the specified name, using the provided key selector to generate index keys for
    /// values.
    /// </summary>
    /// <remarks>Value indexes enable efficient lookups and queries based on the key generated by the
    /// key selector. Adding an index with a duplicate name may result in an error or overwrite, depending on the
    /// implementation.</remarks>
    /// <typeparam name="TIndexKey">The type of the key used for indexing. Must be non-nullable.</typeparam>
    /// <param name="name">The unique name of the value index to add. Cannot be null or empty.</param>
    /// <param name="keySelector">A function that extracts the index key from a value. Cannot be null.</param>
    void AddValueIndex<TIndexKey>(string name, Func<TValue, TIndexKey> keySelector)
        where TIndexKey : notnull;

    /// <summary>
    /// Attempts to add the specified key and value to the collection.
    /// </summary>
    /// <remarks>This method does not throw an exception if the key already exists in the collection.
    /// The behavior when adding a duplicate key depends on the implementation.</remarks>
    /// <param name="key">The key of the element to add. Cannot be null if null keys are not supported by the implementation.</param>
    /// <param name="value">The value of the element to add.</param>
    /// <returns>true if the key and value were added successfully; otherwise, false. Returns false if an element with the
    /// same key already exists.</returns>
    bool TryAdd(TKey key, TValue value);

    /// <summary>
    /// Looks up the value associated with the specified key.
    /// </summary>
    /// <remarks>This method provides an optional-style lookup pattern, returning a tuple indicating
    /// whether the key was found and the associated value.</remarks>
    /// <param name="key">The key to look up.</param>
    /// <returns>A tuple containing a boolean indicating if the key was found and the value if present.</returns>
    (bool HasValue, TValue? Value) Lookup(TKey key);

    /// <summary>
    /// Removes all entries with keys in the specified collection from the dictionary.
    /// </summary>
    /// <param name="keys">The collection of keys to remove.</param>
    void RemoveKeys(IEnumerable<TKey> keys);

    /// <summary>
    /// Removes all entries that match the specified predicate from the dictionary.
    /// </summary>
    /// <param name="predicate">A function that returns true for entries that should be removed.</param>
    /// <returns>The number of entries removed from the dictionary.</returns>
    int RemoveMany(Func<KeyValuePair<TKey, TValue>, bool> predicate);

    /// <summary>
    /// Performs a batch edit operation on the dictionary, ensuring only a single change notification is emitted.
    /// </summary>
    /// <remarks>Use this method when making multiple modifications to the dictionary to improve efficiency
    /// by reducing the number of change notifications.</remarks>
    /// <param name="editAction">An action that receives the dictionary interface to perform modifications.</param>
    void Edit(Action<IDictionary<TKey, TValue>> editAction);

    /// <summary>
    /// Retrieves all values that match the specified key in the given secondary value index.
    /// </summary>
    /// <typeparam name="TIndexKey">The type of the key used to query the secondary index.</typeparam>
    /// <param name="indexName">The name of the secondary index to query.</param>
    /// <param name="key">The key value to search for within the specified index.</param>
    /// <returns>An enumerable collection of values that match the specified key.</returns>
    IEnumerable<TValue> GetValuesBySecondaryIndex<TIndexKey>(string indexName, TIndexKey key)
        where TIndexKey : notnull;

    /// <summary>
    /// Determines whether the specified value matches the given key in the specified secondary index.
    /// </summary>
    /// <typeparam name="TIndexKey">The type of the key used in the secondary index.</typeparam>
    /// <param name="indexName">The name of the secondary index to use for matching.</param>
    /// <param name="value">The value to check.</param>
    /// <param name="key">The key value to match against.</param>
    /// <returns><see langword="true"/> if the value's indexed property matches the specified key; otherwise, <see langword="false"/>.</returns>
    bool ValueMatchesSecondaryIndex<TIndexKey>(string indexName, TValue value, TIndexKey key)
        where TIndexKey : notnull;
}
#endif
