// Copyright (c) Chris Pulman. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
#if NET6_0_OR_GREATER

namespace CP.Reactive;

/// <summary>
/// Represents a dictionary that supports standard key-value storage as well as additional value-based indexing and
/// bulk operations.
/// </summary>
/// <remarks>In addition to the standard IDictionary functionality, IQuaternaryDictionary provides methods
/// for adding or updating entries, adding multiple entries at once, and creating named indexes on value properties
/// for efficient lookups. This interface is intended for scenarios where advanced indexing and bulk operations are
/// required beyond those provided by typical dictionary implementations.</remarks>
/// <typeparam name="TKey">The type of keys in the dictionary. Must be non-nullable.</typeparam>
/// <typeparam name="TValue">The type of values stored in the dictionary.</typeparam>
public interface IQuaternaryDictionary<TKey, TValue> : IDictionary<TKey, TValue>
    where TKey : notnull
{
    /// <summary>
    /// Adds a new element with the specified key and value, or updates the value if the key already exists.
    /// </summary>
    /// <param name="key">The key of the element to add or update. Cannot be null.</param>
    /// <param name="value">The value to set for the specified key.</param>
    void AddOrUpdate(TKey key, TValue value);

    /// <summary>
    /// Adds the elements of the specified collection to the current collection.
    /// </summary>
    /// <param name="pairs">The collection of key/value pairs to add. Each pair is added to the collection. Cannot be null.</param>
    void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);

    /// <summary>
    /// Adds a value index with the specified name, using the provided key selector to generate index keys for
    /// values.
    /// </summary>
    /// <remarks>Value indexes enable efficient lookups and queries based on the key generated by the
    /// key selector. Adding an index with a duplicate name may result in an error or overwrite, depending on the
    /// implementation.</remarks>
    /// <typeparam name="TIndexKey">The type of the key used for indexing. Must be non-nullable.</typeparam>
    /// <param name="name">The unique name of the value index to add. Cannot be null or empty.</param>
    /// <param name="keySelector">A function that extracts the index key from a value. Cannot be null.</param>
    void AddValueIndex<TIndexKey>(string name, Func<TValue, TIndexKey> keySelector)
        where TIndexKey : notnull;

    /// <summary>
    /// Attempts to add the specified key and value to the collection.
    /// </summary>
    /// <remarks>This method does not throw an exception if the key already exists in the collection.
    /// The behavior when adding a duplicate key depends on the implementation.</remarks>
    /// <param name="key">The key of the element to add. Cannot be null if null keys are not supported by the implementation.</param>
    /// <param name="value">The value of the element to add.</param>
    /// <returns>true if the key and value were added successfully; otherwise, false. Returns false if an element with the
    /// same key already exists.</returns>
    bool TryAdd(TKey key, TValue value);
}
#endif
